# ch6.3 프록시
마치 자신이 클라이언트가 사용하려는 실제 대상인듯 위장해서 클라이언트의 요청을 대신 받아주는 것을 대리자, 대리인과 같은 역할을 한다고해서 <strong>프록시</strong>라고 한다

## 예시
A라는 인터페이스가 있다. 

그리고 트랜잭션 기능을 담고있는 A-a와 비지니스 로직을 담고있는 A-b 라는 A의 구현 클래스들이 있다.


클라이언트에서는 A-a와 A-b의 존재 자체를 모르지만 A의 메서드를 호출해서 기능을 사용한다.

A-a는 클라이언트의 요청을 받아서 트랜잭션 기능을 부여해주며 핵심기능을 수행하는 A-b에게 요청이 넘어가도록 해준다.

여기서 A-a를 프록시라고 하며 A-b를 타깃 혹은 실체(real object)라고 부른다.

이렇듯 프록시는 타깃이 구현한 인터페이스와 같은 인터페이스를 구현하면서 클라이언트와 타깃 사이에 위치한다.

## 프록시의 사용목적
사용목적에 따라 두가지로 구분할 수 있는데

첫번째는 <strong>클라이언트가 타깃에 접근하는 방법을 제어하기 위해서</strong>다. 

<strong>두번째는 타깃에 부가적인 기능(위의 예시에선 트랜잭션)을 부여해주기 위해서</strong>다.

두 가지 모두 대리 오브젝트라는 개념의 프록시를 사용하는 것은 동일하지만 목적에 따라서 디자인 패턴에서는 다른 패턴으로 구분한다.

클라이언트가 타깃에 접근하는 방법을 제어하기 위해서는 <strong>프록시 패턴</strong>을 사용하며 동적으로 타깃에 부가적인 기능을 부여해주기 위해서는 <strong>데코레이터 패턴</strong>을 사용한다.

## 프록시 팩토리 빈 방식의 장점과 한계
### 프록시 팩토리 빈 방식의 장점

데코레이터 패턴이 적용된 프록시를 사용하면 많은 장점이 있음에도 적극적으로 활용되지 못하는 데에는 두 가지 문제점이 있다.
1. 프록시를 적용한 대상이 구현하고 있는 인터페이스를 구현한 프록시 클래스를 일일이 만들어야 하는 번거러움
1. 부가적인 기능이 여러 메서드에서 반복적으로 나타나서 코드 중복의 발생

<strong>프록시 팩토리 빈</strong>은 이  두 가지 문제를 해결한다.

다이내믹 프록시를 이용하면 <strong>타깃 인터페이스를 구현하는 클래스를 일일이 만드는 번거로움을 해소</strong>할 수 있고, <strong>하나의 핸들러 메서드를 구현하는 것으로 수많은 메서드에 부가기능을 적용할 수 있으니 코드 중복 문제도 해소</strong>할 수 있다.

그리고 팩토리 빈을 이용한 DI까지 더해주면 다이내믹 프록시를 직접 생성하는 번거로운 코드도 필요없다.
</br></br>

### 프록시 팩토리 빈의 한계
#### 프록시를 통해 타깃에 부가기능을 제공하는 것은 메서드 단위로 일어나는 일이다
하나의 클래스 안에 동일한 부가기능을 제공할 메서드가 수백, 수천개가 있을때도 어렵지 않게 제공할 수 있다.

하지만, 한 번에 여러개의 클래스에 공통적인 부가기능을 제공하는 것은 지금까지의 방법으로는 불가능하다.
</br></br>

#### 하나의 타깃에 여러가지 부가기능을 적용하려고 할 때도 문제다
어떤 타깃 오브젝트에 A 기능을 담은 프록시, B 기능을 담은 프록시, C 기능을 담은 프록시.. 들을 적용하려면 프록시 팩토리 빈 설정이 부가기능의 개수만큼 늘어날 것이다.

물론, 코드를 일일이 찾아가며 고치는것보단 xml 설정 파일에서 몇 줄 수정하는것이 비교도 안될만큼 효율적이지만 해당 프록시들을 적용할 서비스 로직을 담고있는 타깃 클래스가 수백, 수천개라면?
</br></br>

#### 핸들러 오브젝트가 프록시 팩토리 빈 개수만큼 만들어진다
핸들러는 타깃 오브젝트를 참조하고 있다. 따라서 똑같은 부가기능을 제공하는 동일한 코드임에도 타깃 오브젝트가 달라지면 새로운 핸들러 객체를 만들어야 한다.

핸들러는 다이내믹 프록시처럼 굳이 팩토리 빈 안에서 만들지 않아도 된다. 스스로 빈으로 등록될 수 있다. 그럼 빈으로 등록하고 싱글톤으로 사용되도록 하면 안될까?

핸들러는 타깃 오브젝트를 참조하고 있기 때문에 해당 핸들러를 적용해야하는 타깃 오브젝트 개수만큼 또 빈으로 등록해야한다.