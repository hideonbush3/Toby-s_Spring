# 사라진 SQLException
JdbcTemplate를 적용하면서 이전에 있었던 throws SQLException 선언이 모두 사라졌다.
이 SQLException은 어디로 사라진 것인가?

## 초난감 예외처리
### 예외 블랙홀
예외를 catch 블록으로 잡고 아무것도 안하거나 그냥 화면에 예외 메시지를 출력하는 것은 예외를 처리한것이 아니다.

예외를 처리할때 반드시 지켜야할 핵심 원칙이 있다.

모든 예외는 적절하게 복구되든지 아니면
작업을 중단시키고 운영자나 개발자에게 분명히 통보돼야 한다.

### 무의미하고 무책임한 throws
예외 처리가 귀찮아서 메서드 선언마다 매번 throws Exception 을 기계적으로 넣는 경우도 있다.

만약 throws Exception 이라는 선언이 돼있는 메서드를 사용할 일이 생기면 골치아파진다.

의미 있는 정보를 얻을 수 없기 때문에 이 메서드를 사용하는 메서드 역시 throws Exception을 붙일 수 밖에 없다.

적절한 처리를 통해 복구 할 수 있는 예외일 수도 있지만 최초로 throws Exception을 선언한 개발자말고는 그 속내를 알 방도가 없다.

## 예외의 종류와 특징
자바에서 throw를 통해 발생시킬 수 있는 예외는 크게 세가지가 있다.
### Error
java.lang.Error 클래스의 서브클래스들
시스템에 뭔가 비정상적인 상황이 발생했을때 사용된다.
주로 자바 VM에서 발생시키는 것이기 때문에 애플리케이션 코드에서 잡으려고 하면 안된다.

### Exception과 체크 예외
java.lang.Exception클래스와 그 서브클래스들
에러와 달리 개발자가 만든 코드의 작업중에 예외상황이 발생했을때 사용된다.

Exception 클래스는 체크 예외와 언체크 예외로 구분된다.
- 체크 예외: Exception의 서브클래스이며 RuntimeException을 상속하지 않는 것들
- 언체크 예외: RuntimeException을 상속한 것들

체크 예외가 선언된 메서드를 사용할 경우 반드시 예외 처리 코드를 작성해야 하며 그렇지 않을 경우 컴파일 에러가 발생한다.

### RuntimeException과 언체크/런타임 예외
RuntimeException을 상속한 예외들은 예외 처리를 강제하지 않기 때문에 언체크 예외라고 불린다.
또는 RuntimeException의 자손 클래스인 이유로 런타임 예외라고 부르기도 한다.

주로 프로그램의 오류가 있을때 발생하도록 의도된 것들이다.

대표적으로 비어있는 참조변수를 참조할때 발생하는 NullPointerException과
메서드를 호출할때 허용되지 않는 값을 파라미터로 전달할때 발생하는 IllegalArgumentException이 있다.

이런 예외들은 조건문을 사용해 예방할 수 있다.
즉, 개발자의 부주의로 인해 예외가 발생할 수 있을때 발생하도록 만든 것이 런타임 예외다.

## 예외처리 방법
### 예외 복구
예외 상황을 파악하고 문제를 해결해서 정상으로 돌려놓는것
ex) 해당 파일이 없어서 IOException이 발생했을 경우 사용자에게 해당 상황을 알려주고 다른 파일을 이용하도록 유도

### 예외처리 회피
예외처리를 자신을 호출한 쪽으로 넘겨버리는것

JdbcTemplate를 사용하는 콜백 오브젝트는 SQLException을 템플릿으로 던진다.
전략은 말그대로 작업내용을 담고 있을 뿐 예외처리는 자신의 역할이 아니라고 보기 때문이다.

### 예외 전환
예외를 복구해 정상적인 상태로 만들 수 없기 때문에 메서드 밖으로 던지는 것

예외 회피와 다른점은 예외를 그대로 던지는 것이 아니고 적절한 예외로 변환해서 던진다는 것이다. 

보통 두가지 목적으로 사용된다.

첫번째는 <span style='color:red'>의미를 분명하게 해줄 수 있는 예외로 바꿔주기 위해서</span>이다

예를 들어 새로운 유저를 등록시키려고 시도했을때 같은 아이디가 있다면 JDBC API는 SQLException을 발생시킨다. 이럴때 DAO 메서드에서 SQLException을 밖으로 던지면 서비스 계층에서는 이 예외의 원인이 무엇인지 알 수가 없다.

이럴땐 DAO에서 SQLException의 정보를 해석해서 사용자 정의 예외로 변환해서 던져줄 필요가 있다.

서비스 오브젝트에서 SQLException의 원인을 해석하는것도 불가능한 것은 아니지만, 특정 기술의 정보를 해석하는 코드를 비지니스 로직에 담는것은 어색하다.

두번째는 <span style='color:red'>예외를 처리하기 쉽고 단순하게 만들기 위해 포장 wrap 하는 것</span>이다.

주로 예외처리를 강제하는 체크 예외를 런타임 예외로 바꾸기 위해 사용한다.

대표적으로 EJBException이 있다. EJB 컴포넌트 코드에서 발생하는 대부분의 체크 예외는 비지니스 로직으로 볼때 의미있는 예외이거나 복구 가능한 예외가 아니다.

이런 경우 런타임 예외인 EJBException으로 변환해서 던지는것이 낫다.

이렇게 런타임 예외로 만들어서 전달하면 EJB는 이를 시스템 익셉션으로 인식하고 트랜잭션을 자동으로 롤백해준다.

## 예외처리 전략
### 런타임 예외의 보편화
체크 예외는 복구할 가능성이 조금이라도 있는 상황에 발생하기 때문에 자바는 이를 처리하는 catch 블록이나 throws 선언을 강제한다.

자바 엔터프라이즈 서버환경에선 독립형 애플리케이션과 달리 예외 발생시 작업을 중지하고 사용자와 바로 소통하면서 작업을 복구할 방법이 없다.

자바의 환경이 서버로 이동하면서 체크 예외의 활용도는 점점 떨어지고 있다. 대응 불가능한 체크 예외라면 빨리 런타임 예외로 전환해서 던지는것이 낫다.

언체크 예외라도 catch 블록으로 잡아서 복구하거나 처리할 수 있다. 하지만, 대개는 복구 불가능한 상황이고 보나마나 RuntimeException으로 포장해서 던져야 할테니 최근에 등장한 표준스펙이나 오픈소스 프레임워크에서는 API가 던지는 예외를 언체크 예외로 정의하는것이
 보편화되고 있다.

 ### 사용자 추가 메서드의 예외처리
 사용자를 추가하는 메서드인 add()에서는 JDBC 코드에서 SQLException이 발생할 수 있는데 그 원인이 아이디 중복인 경우 좀 더 의미있는 예외로 전환해서 던질 수 있을 것이다.


 ```java
 public class DuplicateUserIdException extends RuntimeException { public DuplicateUserIdException(Throwable cause) { super(cause);
} }
```

```java
public void add() throws DuplicateUserIdException { try {
	 	 // JDBC를 이용해 user 정보를 DB에 추가하는 코드 또는 	 	 // 그런 기능이 있는 다른 SQLException을 던지는 메소드를 호출하는 코드
} catch (SQLException e) { if (e.getErrorCode() = = MysqlErrorNumbers.ER_DUP_ENTRY)
	 	 throw new DuplicateUserIdException(e); 	 // 예외 전환
else
	 	 throw new RuntimeException(e);	 	 // 예외 포장
}
}
```
발생한 SQLException의 원인이 아이디 중복일 경우 DuplicateUserIdException으로 전환해서 던지도록 했다.

add()를 호출하는 쪽에서 받은 예외가 DuplicateUserIdException이면 적절한 처리를 할 수 있을 것이다.

그리고 add()를 호출한 오브젝트보다 더 앞단의 오브젝트에서 예외처리를 할 수도 있도록 해주기 위해서 DuplicateUserIdException를 체크 예외가 아닌 런타임 예외로 만들었다.

SQLException은 대부분 복구 불가능한 예외이기 때문에 잡아봤자 처리할 수도 없고 결국엔 throws를 타고 계속 앞으로 전달되다가 애플리케이션 바깥으로 던져질 것이다.

그럴바에는 런타임 예외로 포장해서 add() 메서드를 사용하는 메서드들이 신경쓰지 않도록 해주는것이 낫다.

### 애플리케이션 예외
시스템 또는 외부의 예외상황이 원인이 아니라 애플리케이션 로직에 의해 의도적으로 발생시키고 반드시 catch 해서 무엇인가 조치를 취하도록 하는 예외

예를 들어 사용자가 요청한 금액을 은행계좌에서 출금하는 기능을 가진 메서드가 있을때 이런 메서드의 설계 방법은 두가지가 있다.

>첫번째, 정상적인 출금 처리를 했을때와 잔고부족일때 각각 다른 종류의 리턴값을 돌려준다

예를 들어 정상적인 경우 요청금액을 리턴하고 잔고부족일 경우 특별한 값(0, -1, -999 등)을 리턴하도록 설계하는 것이다.

그런데 리턴값으로 결과를 확인하고 예외상황을 체크하면 불편한 점이 있다.

비정상처리일 경우에 전달하는 값의 표준이란게 없어서 개발자간에 혼란이 생길 수 있다.

그리고 해당 메서드를 호출하는 쪽에서 리턴값을 체크하는 조건문이 자주 등장해서 코드가 지저분해지고 흐름을 파악하기 힘들다.

>두번째, 잔고부족같은 예외 상황에서는 비지니스적인 의미를 담은 예외를 던지도록 만든다


이때 발생하는 예외는 의도적으로 체크 예외로 만든다.
그래서 개발자로 하여금 잔고부족 같은 자주 발생할 수 있는 예외 상황에 대한 처리를 강제하도록 만드는것이 좋다.

아래는 잔고부족을 애플리케이션 예외로 만들어 처리하도록 하는 코드다.
```java
try { BigDecimal balance = account.withdraw(amount);
...
	 // 정상적인 처리 결과를 출력하도록 진행
} catch(InsufficientBalanceException e) {	 // 체크 예외 	 // InsufficientBalanceException에 담긴 인출 가능한 잔고금액 정보를 가져옴
BigDecimal availFunds = e.getAvailFunds();
...
	 // 잔고 부족 안내 메시지를 준비하고 이를 출력하도록 진행
}
```

## SQLException은 어떻게 됐나?
99%의 SQLException은 코드 레벨에서 복구할 수 있는 방법이 없다.

SQLException이 발생하는 상황의 예시는 다음과 같다
- SQL 문법위반
- 제약조건 위반
- DB 서버 다운
- 네트워크 불안정
- DB 커넥션 풀이 꽉차서 DB 커넥션 로드 불가능

시스템의 예외라면 관리자에게 빨리 알리는 것 외엔 방법이 없다.

마찬가지로 애플리케이션 코드의 버그나 미처 다루지 않은 범위를 벗어난 값 때문에 발생하는 예외도 복구할 방법이 없다.

따라서 예외처리 전략을 적용해 반복적이고 무의미한 throws 선언을 더이상 방치하지 말고 가능한 빨리 런타임 예외로 전환해줘야 한다.

스프링의 JdbcTemplate는 이런 예외처리 전략을 따르고 있다.

JdbcTemplate의 템플릿과 콜백에서 발생하는 모든 SQLException을 런타임 예외인 DataAccessException으로 포장해서 던진다.

따라서 JdbcTemplate을 사용하는 메서드에선 꼭 필요할때만 DataAccessException 예외를 잡아서 처리하고 그 외엔 무시해도 된다.

스프링의 API 메서드에 정의돼있는 대부분의 예외도 모두 런타임 예외이다.
