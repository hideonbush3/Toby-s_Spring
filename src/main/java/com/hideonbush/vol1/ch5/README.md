# 서비스 추상화
지금까지 만든 DAO에 트랜잭션을 적용하고, 스프링이 어떻게 성격이 비슷한 여러 종류의 기술을 추상화하고 이를 일관된 방법으로 사용할 수 있도록 지원하는지를 살펴본다.

## 오브젝트에게 데이터를 요구하지말고 작업을 요청하라
OOP의 기본 원리가 무엇이냐..</br>
객체지향의 4대 특징을 댈수도 있고 SOLID 원칙을 댈수도 있을 것이다.

혹은, 실세계의 모든 것들을 객체라는 것으로 인식하고 프로그래밍 하는것이며 재사용성이 뛰어나며 어쩌구저쩌구..

5.1.5에서 가장 클래식한 답이 나온다.

5.1.5에서는 UserService에 집약돼있던 유저 레벨을 업그레이드하는 로직을 책임에 따라 구분해 UserService, User, Level로 산개된다.

말 그대로 리팩토링을 하게되고 UserService, User, Level은 내부 정보를 다루는 자신의 책임에 충실한 기능을 갖게된다.

그리고 필요가 생기면 이런 작업을 수행해달라고 서로에게 요청하는 구조가 된다.

코드를 이해하기 쉬운 구조가 되며 변경이 필요하면 어느 부분을 수정해야할지 쉽게 알아챌수있고 잘못된 작업인 경우 예외를 던질 준비도 완벽히 됐다.

이 챕터 말미에 중요한 이야기가 나오는데

<strong>객체지향적인 코드는 다른 오브젝트의 데이터를 가져와서 작업하는 대신, 다른 오브젝트에게 작업을 해달라고 요청한다. 오브젝트에게 데이터를 요구하지말고 작업을 요청하는것이 OOP의 가장 기본이 되는 원리이다.</strong>

1. UserService에게 유저의 레벨을 업그레이드 해달라는 요청이 들어왔다.
2. UserService는 해당 유저가 업그레이드 가능한 유저인지 판별한다.
2. UserService는 User에게 레벨 변경을 요청한다.
3. User는 Level에게 다음 레벨이 무엇인지 물어본다.
4. User는 Level이 알려준 레벨로 유저 레벨을 변경한다.
5. UserService는 변경된 유저 정보를 UserDao에게 전달한다.

어떻게 해야 더욱 객체지향적인 코드를 설계할 수 있을까? 라는 질문에 가장 쉬우며 정확한 답변인것 같다.

<strong>오브젝트간에 데이터를 요구하도록 하지말고 작업을 요청하도록 설계해라!</strong>

## SRP의 장점
어떤 변경이 필요할때 수정 대상이 명확해진다.

DAO를 하나 수정할때 해당 DAO를 사용하는 서비스 클래스도 같이 수정해야하는 구조라면 프로젝트가 커졌을 경우 엄청난 양의 클래스들을 모두 수정해야한다.

많은 코드를 수정하는 작업은 필연적으로 실수를 동반한다.

그래서 책임과 관심이 다른 코드를 분리하고, 서로 영향을 주지 않도록 다양한 추상화 기법을 도입하고, 애플리케이션 로직과 기술/환경을 분리하는 작업은 갈수록 복잡해져가는 엔터프라이즈 애플리케이션에는 필수적이다.

이를 위한 핵심적인 도구가 스프링의 DI인 것이다.

## 객체지향 설계과 프로그래밍의 원칙은 서로 긴밀하게 관련이 있다
SRP를 잘 지키려면 인터페이스를 도입하고 이를 DI로 연결해야 한다.

그 결과로 SRP뿐 아니라 OCP도 잘 지켜지고, 모듈간의 결합도가 낮아져서 서로의 변경이 서로에게 영향을 끼치지 않게되며 변경이 단일 책임에 집중되는 응집도 높은 코드가 된다.

이런 과정에서 다양한 디자인 패턴이 자연스럽게 적용되기도 한다.

지금까지 코드를 개선하며 DI를 사용하지 않은적은 한번도없다.

1. DAO와 DataSource를 분리할때
1. 효과적인 단위테스트를 만들때
1. 템플릿/콜백 패턴
1. 비지니스 로직을 데이터 액세스 로직과 별도로 분리해서 연결할때
1. 트랜잭션 기술을 추상화해서 비지니스 로직에서 분리할때

이렇게 스프링의 DI는 모든 스프링 기술의 기반이 되는 핵심 엔진이자 원리이며 스프링이 지지하는 좋은 설계를 만드는 모든 과정에서 사용되는 가장 중요한 도구이다.
