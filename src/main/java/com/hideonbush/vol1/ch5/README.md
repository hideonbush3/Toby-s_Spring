# 서비스 추상화
지금까지 만든 DAO에 트랜잭션을 적용하고, 스프링이 어떻게 성격이 비슷한 여러 종류의 기술을 추상화하고 이를 일관된 방법으로 사용할 수 있도록 지원하는지를 살펴본다.

## 오브젝트에게 데이터를 요구하지말고 작업을 요청하라
OOP의 기본 원리가 무엇이냐..</br>
객체지향의 4대 특징을 댈수도 있고 SOLID 원칙을 댈수도 있을 것이다.

혹은, 실세계의 모든 것들을 객체라는 것으로 인식하고 프로그래밍 하는것이며 재사용성이 뛰어나며 어쩌구저쩌구..

5.1.5에서 가장 클래식한 답이 나온다.

5.1.5에서는 UserService에 집약돼있던 유저 레벨을 업그레이드하는 로직을 책임에 따라 구분해 UserService, User, Level로 산개된다.

말 그대로 리팩토링을 하게되고 UserService, User, Level은 내부 정보를 다루는 자신의 책임에 충실한 기능을 갖게된다.

그리고 필요가 생기면 이런 작업을 수행해달라고 서로에게 요청하는 구조가 된다.

코드를 이해하기 쉬운 구조가 되며 변경이 필요하면 어느 부분을 수정해야할지 쉽게 알아챌수있고 잘못된 작업인 경우 예외를 던질 준비도 완벽히 됐다.

이 챕터 말미에 중요한 이야기가 나오는데

<strong>객체지향적인 코드는 다른 오브젝트의 데이터를 가져와서 작업하는 대신, 다른 오브젝트에게 작업을 해달라고 요청한다. 오브젝트에게 데이터를 요구하지말고 작업을 요청하는것이 OOP의 가장 기본이 되는 원리이다.</strong>

1. UserService에게 유저의 레벨을 업그레이드 해달라는 요청이 들어왔다.
2. UserService는 해당 유저가 업그레이드 가능한 유저인지 판별한다.
2. UserService는 User에게 레벨 변경을 요청한다.
3. User는 Level에게 다음 레벨이 무엇인지 물어본다.
4. User는 Level이 알려준 레벨로 유저 레벨을 변경한다.
5. UserService는 변경된 유저 정보를 UserDao에게 전달한다.

어떻게 해야 더욱 객체지향적인 코드를 설계할 수 있을까? 라는 질문에 가장 쉬우며 정확한 답변인것 같다.

<strong>오브젝트간에 데이터를 요구하도록 하지말고 작업을 요청하도록 설계해라!</strong>